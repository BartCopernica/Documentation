<h1>Function mq_context_cleanup</h2>
<p>
    This function is called by MailerQ right before a worker thread is 
    stopped and destroyed. You can for example use it to deallocate
    memory that you had earlier allocated.
</p>
<p>
    This function can be implemented <i>by the plugin</i> and
    is called by MailerQ when a worker thread is about to stop. If the function returns true,
    MailerQ hands over control to your plugin, and your plugin must call one of the 
    functions <a href="/documentation/mq_continue">MQ_Continue()</a>,
    <a href="/documentation/mq_complete">MQ_Complete()</a> or
    <a href="/documentation/mq_retry">MQ_Retry()</a> when it is ready 
    to hand back control to MailerQ. Only <i>after</i> all plugins have
    given back control to MailerQ, the worker thread will really be stopped.
</p>
<p>
    For more information on how MailerQ plugins can interact with the event
    loop, and how control is passed to and from plugins, see 
    <a href="/documentation/eventloop">the article about the MailerQ event loop</a>.
</p>


<pre class="prettyprint lang-c">
#include &lt;mailerq.h&gt;

/**
 *  This function is called by MailerQ for every worker thread
 *  that comes to an end
 */
MQ_EXPORT bool mq_context_cleanup(<a href="/documentation/mq_context">MQ_Context</a> *context) {
    // get the mysql connection resource that we stored in the context
    MYSQL *connection = (MYSQL *)MQ_ContextData(context);
    
    // close the connection
    mysql_close(connection);

    // TODO: add other useful cleanup stuff

    // return false, MailerQ can stay in control
    return false;
}
</pre>
<p>
    Remember that if you return true,
    MailerQ hands over control to your plugin, and your plugin must call one of the 
    functions <a href="/documentation/mq_continue">MQ_Continue()</a>,
    <a href="/documentation/mq_complete">MQ_Complete()</a> or
    <a href="/documentation/mq_retry">MQ_Retry()</a> when it is ready 
    to hand back control to MailerQ.    
</p>
