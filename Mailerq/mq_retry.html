<h1>Function MQ_Retry</h1>
<p>
    MailerQ has a non-blocking nature, and uses callbacks to 
    <a href="/documentation/eventloop">pass control to a plugin</a>. It
    is then up to the plugin to interact with the event loop, and pass
    control back to MailerQ when it is ready with its task. Passing 
    back control can be done in three different ways:
</p>
<ul>
    <li>Tell MailerQ to run the next plugin (the normal way of returning control)</li>
    <li>Tell MailerQ to skip all other plugins</li>
    <li>Tell MailerQ to call the first plugin again</li>
</ul>
<p>
    The <a href="/documentation/mq_retry">MQ_Retry()</a> implements
    the third behavior, and is probably the most peculiar way of handing
    back control to MailerQ. If you call it, MailerQ will start all over,
    and will call all plugins again.
</p>
<p>
    This is a very odd way of handing back control, and you normally
    should not use it, because you run the risk of ending up in an infinite
    loop. It could however be useful if your plugin makes a change
    to a received message, and you want to run all plugins again so that
    they can all respond to the modified message.
</p>
<pre class="language-c"><code class="language-c">
/**
 *  Finish plugin processing
 *
 *  @param  context the context that may move on to the next plugin
 */
void <a href="/documentation/mq_retry">MQ_Retry</a>(<a href="/documentation/mq_retry">MQ_Context</a> *context);
</code></pre>

<p>
    See also <a href="/documentation/mq_continue">MQ_Continue()</a> and
    <a href="/documentation/mq_complete">MQ_Complete()</a> for the other
    (and probably more useful) ways of handing back control.
</p>
